%------------------------------------- Apêndice 1 ---------------------------------------------------
\chapter{Apêndice 1}
\label{Apendice1}

%%Remover
%\textcolor{red}{\textbf{Dica:} Diferença entre Apêndice e Anexo:
%	\begin{itemize}
%		\item APÊNDICE -- Documento ou texto elaborado pelo autor
%		\item ANEXO -- Documento ou texto não elaborado pelo autor
%	\end{itemize}
%}

Todos os trechos de código desenvolvidos para a estação-base da interface gráfica e para as outras plataformas podem ser encontradas no seguinte repositório:

Link para o Repositório: \url{https://github.com/nicolasrosa/StereoVision}

%Abaixo estão apresentados todos os trechos de código desenvolvidos para a interface gráfica implementada para a estação-base. Essa seção está subdividada em duas partes, bibliotecas e código-fonte. 
%
%\section{Interface Gráfica - StereoVision System}
%\subsection{Bibliotecas}
%
%\lstset{language=C++}
%\textbf{mainwindow.h}
%\begin{lstlisting}
%/*
% * mainwindow.h
% *
% *  Created on: Oct 1, 2015
% *      Author: nicolasrosa
% */
%
%#ifndef MAINWINDOW_H
%#define MAINWINDOW_H
%
%/* Libraries */
%#include <QMainWindow>
%#include <opencv2/opencv.hpp>
%
%/* Custom Libraries */
%#include "StereoProcessor.h"
%#include "setstereoparams.h"
%
%using namespace cv;
%
%namespace Ui{
%    class MainWindow;
%}
%
%class MainWindow : public QMainWindow{
%    Q_OBJECT
%
%public:
%    explicit MainWindow(QWidget *parent = 0);
%    void StereoVisionProcessInit();
%    void printHelp();
%    void openStereoSource(int inputNum);
%    void createTrackbars();
%    QImage putImage(const Mat& mat);
%    ~MainWindow();
%
%private:
%    Ui::MainWindow *ui;
%    StereoProcessor *stereo;
%    SetStereoParams *stereoParamsSetupWindow;
%
%    QImage qimageL,qimageR;
%
%    QTimer* tmrTimer;
%
%public slots:
%    void StereoVisionProcessAndUpdateGUI();
%
%private slots:
%    void on_btnPauseOrResume_clicked();
%    void on_btnShowDisparityMap_clicked();
%    void on_btnShowStereoParamSetup_clicked();
%    void on_btnShow3DReconstruction_clicked();
%    void on_btnShowInputImages_clicked();
%    void on_btnShowTrackingObjectView_clicked();
%    void on_btnShowDiffImage_clicked();
%    void on_btnShowDiffImage_2_clicked();
%};
%
%#endif // MAINWINDOW_H
%\end{lstlisting}
%
%\textbf{reprojectImageTo3D.h}
%\begin{lstlisting}
%/*
% * reprojectImageTo3D.h
% *
% *  Created on: Jun 18, 2015
% *      Author: nicolasrosa
% */
%
%#ifndef reproject_Image_To_3D_LIB_H_
%#define reproject_Image_To_3D_LIB_H_
%
%/* Libraries */
%#include <opencv2/opencv.hpp>
%#include <fstream>
%
%using namespace cv;
%
%/* Calibration */
%#define RESOLUTION_640x480
%//#define RESOLUTION_1280x720
%#define CALIBRATION_ON
%
%/* Functions Scope */
%void on_trackbar(int,void*);
%
%void imageProcessing1(Mat img, Mat imgMedian, Mat imgMedianBGR);
%void imageProcessing2(Mat src, Mat imgE, Mat imgED,Mat cameraFeedL,bool isTrackingObjects);
%
%void resizeFrames(Mat* frame1,Mat* frame2);
%void changeResolution(VideoCapture* cap_l,VideoCapture* cap_r);
%void contrast_and_brightness(Mat &left,Mat &right,float alpha,float beta);
%
%/* Global Variables */
%bool isVideoFile=false;
%bool isImageFile=false;
%bool needCalibration=false;
%bool isStereoParamSetupTrackbarsCreated=false;
%bool isTrackingObjects=true;
%
%#endif /* reproject_Image_To_3D_LIB_H_ */
%\end{lstlisting}
%
%\textbf{setstereoparams.h}
%\begin{lstlisting}
%/*
% * setstereoparams.h
% *
% *  Created on: Oct 1, 2015
% *      Author: nicolasrosa
% */
%
%#ifndef SETSTEREOPARAMS_H
%#define SETSTEREOPARAMS_H
%
%#include <QDialog>
%
%class StereoProcessor; // forward-declaration
%
%namespace Ui {
%    class SetStereoParams;
%}
%
%class SetStereoParams : public QDialog{
%    Q_OBJECT
%
%public:
%    explicit SetStereoParams(QWidget *parent = 0, StereoProcessor *stereo = 0);
%    void loadStereoParamsUi(int preFilterSize,int preFilterCap,int SADWindowSize,int minDisparity,int numberOfDisparities,int textureThreshold,int uniquenessRatio, int speckleWindowSize, int speckleRange,int disp12MaxDiff);
%
%    ~SetStereoParams();
%
%    bool isAlreadyShowing;
%
%signals:
%    void valuesChanged(int preFilterSize, int preFilterCap, int sadWindowSize, int minDisparity, int numOfDisparities, int textureThreshold, int uniquenessRatio, int speckleWindowSize, int speckleWindowRange, int disp12MaxDiff);
%private slots:
%    /* Sliders */
%    void on_preFilterSize_slider_valueChanged(int value);
%    void on_preFilterCap_slider_valueChanged(int value);
%    void on_SADWindowSize_slider_valueChanged(int value);
%    void on_minDisparity_slider_valueChanged(int value);
%    void on_numberOfDisparities_slider_valueChanged(int value);
%    void on_textureThreshold_slider_valueChanged(int value);
%    void on_uniquenessRatio_slider_valueChanged(int value);
%    void on_speckleWindowSize_slider_valueChanged(int value);
%    void on_speckleRange_slider_valueChanged(int value);
%    void on_disp12MaxDiff_slider_valueChanged(int value);
%
%    /* SpinBoxes */
%    void on_preFilterSize_spinBox_valueChanged(int value);
%    void on_preFilterCap_spinBox_valueChanged(int value);
%    void on_SADWindowSize_spinBox_valueChanged(int value);
%    void on_minDisparity_spinBox_valueChanged(int value);
%    void on_numberOfDisparities_spinBox_valueChanged(int value);
%    void on_textureThreshold_spinBox_valueChanged(int value);
%    void on_uniquenessRatio_spinBox_valueChanged(int value);
%    void on_speckleWindowSize_spinBox_valueChanged(int value);
%    void on_speckleRange_spinBox_valueChanged(int value);
%    void on_disp12MaxDiff_spinBox_valueChanged(int value);
%
%    void on_buttonBox_accepted();
%    void on_buttonBox_rejected();
%
%private:
%    Ui::SetStereoParams *ui;
%    StereoProcessor *stereo;
%
%    void updateValues();
%};
%
%#endif // SETSTEREOPARAMS_H
%\end{lstlisting}
%
%\textbf{StereoCalib.h}
%\begin{lstlisting}
%/*
% * StereoCalib.h
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#ifndef STEREOCALIB_H
%#define STEREOCALIB_H
%
%/* Libraries */
%#include <string>
%#include <opencv2/opencv.hpp>
%
%using namespace cv;
%using namespace std;
%
%class StereoCalib{
%public:
%    StereoCalib(); //Constructor
%    void readQMatrix();
%    void calculateQMatrix();
%    void createKMatrix();
%
%    string intrinsicsFileName;
%    string extrinsicsFileName;
%    string QmatrixFileName;
%    string StereoParamFileName;
%
%    Point2d imageCenter;
%
%    Mat K,Q;
%    double focalLength;
%    double baseline;
%    bool is320x240;
%    bool is640x480;
%    bool is1280x720;
%
%    Mat M1,D1,M2,D2;
%    Mat R,T,R1,P1,R2,P2;
%    Rect roi1, roi2;
%    bool isKcreated;
%};
%
%#endif // STEREOCALIB_H
%\end{lstlisting}
%
%\textbf{StereoConfig.h}
%\begin{lstlisting}
%/*
% * StereoConfig.h
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#ifndef STEREOCONFIG_H
%#define STEREOCONFIG_H
%
%class StereoConfig{
%public:
%    StereoConfig(); //Constructor
%    //StereoConfig getConfig();
%
%    int preFilterSize;
%    int preFilterCap;
%    int SADWindowSize;
%    int minDisparity;
%    int numberOfDisparities;
%    int textureThreshold;
%    int uniquenessRatio;
%    int speckleWindowSize;
%    int speckleRange;
%    int disp12MaxDiff;
%};
%
%#endif // STEREOCONFIG_H
%\end{lstlisting}
%
%\textbf{StereoCustom.h}
%\begin{lstlisting}
%/*
% * StereoCustom.h
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#ifndef STEREOCUSTOM_H
%#define STEREOCUSTOM_H
%
%/* Libraries */
%#include <string>
%
%using namespace std;
%
%/* Global Variables */
%const string trackbarWindowName = "Stereo Param Setup";
%//bool isVideoFile=false,isImageFile=false,needCalibration=false,isStereoParamSetupTrackbarsCreated=false,isTrackingObjects=true;;
%
%/* Threshold, Erosion, Dilation and Blur Constants */
%#define THRESH_VALUE   100
%#define EROSION_SIZE     5
%#define DILATION_SIZE    5
%#define BLUR_SIZE        3
%
%/* Trackbars Variables
% * Initial min and max BM Parameters values.These will be changed using trackbars
% */
%const int preFilterSize_MAX		 	= 100;
%const int preFilterCap_MAX		 	= 100;
%const int SADWindowSize_MAX		 	= 100;
%const int minDisparity_MAX		 	= 100;
%const int numberOfDisparities_MAX 	= 16;
%const int textureThreshold_MAX		= 100;
%const int uniquenessRatio_MAX		= 100;
%const int speckleWindowSize_MAX	 	= 100;
%const int speckleRange_MAX		 	= 100;
%const int disp12MaxDiff_MAX		 	= 1;
%
%#endif // STEREOCUSTOM_H
%\end{lstlisting}
%
%\textbf{StereoDiff.h}
%\begin{lstlisting}
%/*
% * StereoDiff.h
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#ifndef STEREODIFF_H
%#define STEREODIFF_H
%
%/* Libraries */
%#include <opencv2/opencv.hpp>
%
%using namespace cv;
%using namespace std;
%
%class StereoDiff{
%public:
%    StereoDiff(); //Constructor
%    void createDiffImage(Mat,Mat);
%    void createResAND(Mat,Mat);
%    void convertToBGR();
%    void addRedLines();
%
%    bool StartDiff;
%    Mat diffImage;
%
%    Mat res_AND;
%    Mat imageL;
%    Mat res_AND_BGR;
%    Mat res_AND_BGR_channels[3];
%
%    double alpha;
%    double beta;
%    Mat res_ADD;
%};
%
%#endif // STEREODIFF_H
%\end{lstlisting}
%
%\textbf{StereoDisparityMap.h}
%\begin{lstlisting}
%/*
% * StereoDisparityMap.h
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#ifndef STEREODISPARITYMAP_H
%#define STEREODISPARITYMAP_H
%
%/* Libraries */
%#include <opencv2/opencv.hpp>
%
%using namespace cv;
%using namespace std;
%
%class StereoDisparityMap{
%public:
%    StereoDisparityMap(); //Constructor
%
%    Mat disp_16S;
%    Mat disp_8U;
%    Mat disp_BGR;
%};
%
%#endif // STEREODISPARITYMAP_H
%\end{lstlisting}
%
%\textbf{StereoFlags.h}
%\begin{lstlisting}
%/*
% * StereoFlags.h
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#ifndef STEREOFLAGS_H
%#define STEREOFLAGS_H
%
%class StereoFlags{
%public:
%    StereoFlags(); //Constructor
%
%    bool showInputImages;
%    bool showXYZ;
%    bool showStereoParam;
%    bool showStereoParamValues;
%    bool showFPS;
%    bool showDisparityMap;
%    bool show3Dreconstruction;
%    bool showTrackingObjectView;
%    bool showDiffImage;
%    bool showWarningLines;
%};
%
%#endif // STEREOFLAGS_H
%\end{lstlisting}
%
%\textbf{StereoProcessor.h}
%\begin{lstlisting}
%/*
% * StereoProcessor.h
% *
% *  Created on: Oct 20, 2015
% *      Author: nicolasrosa
% */
%
%#ifndef STEREOPROCESSOR_H
%#define STEREOPROCESSOR_H
%
%/* Libraries */
%#include <opencv2/opencv.hpp>
%
%/* Custom Libraries */
%#include "StereoCalib.h"
%#include "StereoCustom.h"
%#include "StereoConfig.h"
%#include "StereoDiff.h"
%#include "StereoDisparityMap.h"
%#include "StereoFlags.h"
%
%#include "3DReconstruction.h"
%
%using namespace cv;
%using namespace std;
%
%class StereoProcessor : public StereoConfig{
%public:
%    StereoProcessor(int inputNum); //Constructor
%    int getInputNum();
%
%    void readConfigFile();
%    void readStereoConfigFile();
%
%    void stereoInit();
%    void stereoCalib();
%    void setStereoParams();
%    void setValues(int preFilterSize, int preFilterCap, int sadWindowSize, int minDisparity, int numOfDisparities, int textureThreshold, int uniquenessRatio, int speckleWindowSize, int speckleWindowRange, int disp12MaxDiff);
%
%    void imageProcessing(Mat src, Mat imgE, Mat imgED,Mat trackingView,bool isTrackingObjects);
%
%    void saveLastFrames();
%
%    Mat imageL[2],imageR[2];
%    Mat	imageL_grey[2],imageR_grey[2];
%    VideoCapture capL,capR;
%
%    Ptr<StereoBM> bm;
%    StereoCalib calib;
%    StereoConfig stereocfg;
%    StereoDisparityMap disp;
%    Reconstruction3D view3D;
%    StereoDiff diff;
%    StereoFlags flags;
%    Size imageSize;
%    int numRows;
%
%    /* Results */
%    Mat imgThreshold;
%    Mat trackingView;
%
%    bool showStereoParamsValues;
%
%private:
%    int inputNum;
%};
%
%#endif // STEREOPROCESSOR_H
%\end{lstlisting}
%
%\subsection{Códigos-Fonte}
%
%\textbf{main.cpp}
%\begin{lstlisting}
%#include "mainwindow.h"
%
%#include <QApplication>
%
%//#include <QHBoxLayout>
%//#include <QSlider>
%//#include <QSpinBox>
%
%int main(int argc, char *argv[]){
%    QApplication app(argc, argv);
%    MainWindow mainwindow;
%
%    mainwindow.show();
%
%//    QWidget *window = new QWidget;
%//    window->setWindowTitle("Enter Your Age");
%
%//    QSpinBox *spinBox = new QSpinBox;
%//    QSlider *slider = new QSlider(Qt::Horizontal);
%//    spinBox->setRange(0, 130);
%//    slider->setRange(0, 130);
%
%//    QObject::connect(spinBox, SIGNAL(valueChanged(int)),slider, SLOT(setValue(int)));
%//    QObject::connect(slider, SIGNAL(valueChanged(int)),spinBox, SLOT(setValue(int)));
%//    spinBox->setValue(35);
%
%//    QHBoxLayout *layout = new QHBoxLayout;
%
%//    layout->addWidget(spinBox);
%//    layout->addWidget(slider);
%//    window->setLayout(layout);
%
%//    window->show();
%
%    return app.exec();
%}
%\end{lstlisting}
%
%\textbf{mainwindow.cpp}
%\begin{lstlisting}
%/* Project: reprojectImageTo3D - BlockMatching Algorithm
% * mainwindow.cpp
% *
% *  Created on: June, 2015
% *      Author: nicolasrosa
% *
% * // Credits: http://opencv.jp/opencv2-x-samples/point-cloud-rendering
% * // Credits: Kyle Hounslow - https://www.youtube.com/watch?v=bSeFrPrqZ2A
% */
%
%/* Libraries */
%#include <QtCore>
%#include <opencv2/imgproc/imgproc.hpp>
%
%/* Custom Libraries */
%#include "reprojectImageTo3D.h"
%#include "mainwindow.h"
%#include "ui_mainwindow.h"
%
%using namespace cv;
%using namespace std;
%
%void writeMatToFile(cv::Mat& m, const char* filename);
%
%//MainWindow::MainWindow(QWidget *parent):QMainWindow(parent),ui(new Ui::MainWindow),stereo(new StereoProcessor(6)){
%MainWindow::MainWindow(QWidget *parent):QMainWindow(parent),ui(new Ui::MainWindow){
%    ui->setupUi(this);
%
%    this->stereo = new StereoProcessor(1);
%    StereoVisionProcessInit();
%
%    tmrTimer = new QTimer(this);
%    connect(tmrTimer,SIGNAL(timeout()),this,SLOT(StereoVisionProcessAndUpdateGUI()));
%    tmrTimer->start(20);
%}
%
%MainWindow::~MainWindow(){
%    delete ui;
%}
%
%void MainWindow::on_btnPauseOrResume_clicked(){
%    if(tmrTimer->isActive() == true){
%        tmrTimer->stop();
%        cout << "Paused!" << endl;
%        ui->btnPauseOrResume->setText("Resume");
%    }else{
%        tmrTimer->start(20);
%        cout << "Resumed!" << endl;
%        ui->btnPauseOrResume->setText("Pause");
%    }
%}
%
%void MainWindow::on_btnShowStereoParamSetup_clicked(){
%    stereoParamsSetupWindow = new SetStereoParams(this, stereo);
%
%    cout << "[Stereo Param Setup] Stereo Parameters Configuration Loaded!" << endl;
%    this->stereoParamsSetupWindow->loadStereoParamsUi(stereo->stereocfg.preFilterSize,
%                                                      stereo->stereocfg.preFilterCap,
%                                                      stereo->stereocfg.SADWindowSize,
%                                                      stereo->stereocfg.minDisparity,
%                                                      stereo->stereocfg.numberOfDisparities,
%                                                      stereo->stereocfg.textureThreshold,
%                                                      stereo->stereocfg.uniquenessRatio,
%                                                      stereo->stereocfg.speckleWindowSize,
%                                                      stereo->stereocfg.speckleRange,
%                                                      stereo->stereocfg.disp12MaxDiff);
%    stereoParamsSetupWindow->show();
%}
%
%void MainWindow::StereoVisionProcessInit(){
%    cerr << "Arrumar a Matrix K, os valores das últimas colunas estão errados." << endl;
%    cerr << "Arrumar a função StereoProcessor::calculateQMatrix()." << endl;
%    cerr << "Arrumar o Constructor da classe StereoDisparityMap para Alocação de Memória das variáveis: disp_16S,disp_8U,disp_BGR" << endl;
%    cerr << "Arrumar o tipo de execução da Stereo Param Setup, fazer com que a execução da main não pause." << endl;
%    cerr << "Arrumar a funcionalidade do Botão Pause/Resume, não está funcionando." << endl;
%
%    printHelp();
%
%    //(1) Open Image Source
%    openStereoSource(stereo->getInputNum());
%    stereo->readConfigFile();
%    stereo->readStereoConfigFile();
%
%    //(2) Camera Setting
%
%    // Checking Resolution
%    stereo->calib.is320x240  = false;
%    stereo->calib.is640x480  = true;
%    stereo->calib.is1280x720 = false;
%
%    if(isVideoFile){
%        stereo->imageSize.width = stereo->capL.get(CV_CAP_PROP_FRAME_WIDTH);
%        stereo->imageSize.height = stereo->capL.get(CV_CAP_PROP_FRAME_HEIGHT);
%    }else{
%        stereo->imageSize.width = stereo->imageL[0].cols;
%        stereo->imageSize.height = stereo->imageL[0].rows;
%    }
%
%    if(stereo->imageSize.width==0 && stereo->imageSize.height==0){
%        cerr << "Number of Cols and Number of Rows equal to ZERO!" << endl;
%    }else{
%        cout << "Input Resolution(Width,Height): (" << stereo->imageSize.width << "," << stereo->imageSize.height << ")" << endl << endl;
%    }
%
%    //(3) Stereo Initialization
%    stereo->bm = StereoBM::create(16,9);
%    stereo->stereoInit();
%
%    //(4) Stereo Calibration
%    if(needCalibration){
%        cout << "Calibration: ON" << endl;
%        stereo->stereoCalib();
%
%        // Compute the Q Matrix
%        stereo->calib.readQMatrix(); //true=640x480 false=others
%
%        //Point2d imageCenter = Point2d((imageL[0].cols-1.0)/2.0,(imageL[0].rows-1.0)/2.0);
%        //calculateQMatrix();
%
%        // Compute the K Matrix
%        ////        // Checking Intrinsic Matrix
%        ////        if(stereo->calib.isKcreated){
%        ////           cout << "The Intrinsic Matrix is already Created." << endl << endl;
%        ////        }else{
%        //            //createKMatrix();
%        // //       }
%        stereo->calib.createKMatrix();
%
%    }else{
%        cout << "Calibration: OFF" << endl << endl;
%        cerr << "Warning: Couldn't generate 3D Reconstruction. Please, check Q,K Matrix." << endl;
%
%        //stereo->readQMatrix(); //true=640x480 false=others
%        //stereo->createKMatrix();
%    }
%
%    //Setting StereoBM Parameters
%    stereo->setStereoParams();
%
%    //(5) Point Cloud Initialization
%    stereo->view3D.PointCloudInit(stereo->calib.baseline/10,true);
%
%    stereo->view3D.setViewPoint(20.0,20.0,-stereo->calib.baseline*10);
%    stereo->view3D.setLookAtPoint(22.0,16.0,stereo->calib.baseline*10.0);
%
%}
%
%void MainWindow::StereoVisionProcessAndUpdateGUI(){
%    //Local Variables
%    char key=0;
%
%    //Timing
%    int frameCounter=0;
%    int fps,lastTime = clock();
%
%    //(6) Rendering Loop
%    while(key!='q'){
%        if(isVideoFile){
%            stereo->capL >> stereo->imageL[0];
%            stereo->capR >> stereo->imageR[0];
%
%            resizeFrames(&stereo->imageL[0],&stereo->imageR[0]);
%
%            if(needCalibration){
%                stereo->imageSize = stereo->imageL[0].size();
%                stereoRectify(stereo->calib.M1,stereo->calib.D1,stereo->calib.M2,stereo->calib.D2,stereo->imageSize,stereo->calib.R,stereo->calib.T,stereo->calib.R1,stereo->calib.R2,stereo->calib.P1,stereo->calib.P2,stereo->calib.Q,CALIB_ZERO_DISPARITY,-1,stereo->imageSize,&stereo->calib.roi1,&stereo->calib.roi2);
%                Mat rmap[2][2];
%
%                initUndistortRectifyMap(stereo->calib.M1, stereo->calib.D1, stereo->calib.R1, stereo->calib.P1, stereo->imageSize, CV_16SC2, rmap[0][0], rmap[0][1]);
%                initUndistortRectifyMap(stereo->calib.M2, stereo->calib.D2, stereo->calib.R2, stereo->calib.P2, stereo->imageSize, CV_16SC2, rmap[1][0], rmap[1][1]);
%                Mat imageLr, imageRr;
%                remap(stereo->imageL[0], imageLr, rmap[0][0], rmap[0][1], INTER_LINEAR);
%                remap(stereo->imageR[0], imageRr, rmap[1][0], rmap[1][1], INTER_LINEAR);
%
%                stereo->imageL[0] = imageLr;
%                stereo->imageR[0] = imageRr;
%            }
%        }
%
%        //Setting StereoBM Parameters
%        //stereo->setStereoParams();
%
%        // Convert BGR to Grey Scale
%        cvtColor(stereo->imageL[0],stereo->imageL_grey[0],CV_BGR2GRAY);
%        cvtColor(stereo->imageR[0],stereo->imageR_grey[0],CV_BGR2GRAY);
%
%        stereo->bm->compute(stereo->imageL_grey[0],stereo->imageR_grey[0],stereo->disp.disp_16S);
%        //fillOcclusion(disp,16,false);
%
%        normalize(stereo->disp.disp_16S, stereo->disp.disp_8U, 0, 255, CV_MINMAX, CV_8U);
%        applyColorMap(stereo->disp.disp_8U,stereo->disp.disp_BGR, COLORMAP_JET);
%
%        /* Image Processing */
%        Mat disp_8Ueroded;Mat disp_8U_eroded_dilated;
%
%        stereo->imageProcessing(stereo->disp.disp_8U,disp_8Ueroded,disp_8U_eroded_dilated,stereo->imageL[0],true);
%
%        //(7) Projecting 3D point cloud to image
%        if(stereo->flags.show3Dreconstruction){
%            cv::reprojectImageTo3D(stereo->disp.disp_16S,stereo->view3D.depth,stereo->calib.Q);
%            Mat xyz = stereo->view3D.depth.reshape(3,stereo->view3D.depth.size().area());
%
%            stereo->view3D.lookat(stereo->view3D.viewpoint, stereo->view3D.lookatpoint , stereo->view3D.Rotation);
%            stereo->view3D.t.at<double>(0,0)=stereo->view3D.viewpoint.x;
%            stereo->view3D.t.at<double>(1,0)=stereo->view3D.viewpoint.y;
%            stereo->view3D.t.at<double>(2,0)=stereo->view3D.viewpoint.z;
%
%            if(stereo->flags.showXYZ){
%                //cout<< stereo->view3D.t <<endl;
%                cout << "x: " << stereo->view3D.t.at<double>(0,0) << endl;
%                cout << "y: " << stereo->view3D.t.at<double>(1,0) << endl;
%                cout << "z: " << stereo->view3D.t.at<double>(2,0) << endl;
%            }
%
%            stereo->view3D.t=stereo->view3D.Rotation*stereo->view3D.t;
%
%            //projectImagefromXYZ(imageL[0],disp3Dviewer,disp,disp3D,xyz,Rotation,t,K,dist,isSub);
%            stereo->view3D.projectImagefromXYZ(stereo->disp.disp_BGR,stereo->view3D.disp3D_BGR,stereo->disp.disp_16S,stereo->view3D.disp3D,xyz,stereo->view3D.Rotation,stereo->view3D.t,stereo->calib.K,stereo->view3D.dist,stereo->view3D.isSub);
%
%            // GUI Output
%            stereo->view3D.disp3D.convertTo(stereo->view3D.disp3D_8U,CV_8U,0.5);
%            //imshow("3D Depth",disp3D);
%            //imshow("3D Viewer",disp3Dviewer);
%            //imshow("3D Depth RGB",disp3DBGR);
%
%            QImage qimageL = putImage(stereo->view3D.disp3D_8U);
%            QImage qimageR = putImage(stereo->view3D.disp3D_BGR);
%
%            ui->lblOriginalLeft->setPixmap(QPixmap::fromImage(qimageL));
%            ui->lblOriginalRight->setPixmap(QPixmap::fromImage(qimageR));
%        }
%
%        //(8)Movement Difference between Frames
%        //if(stereo->diff.StartDiff){
%        if(stereo->flags.showDiffImage || stereo->flags.showWarningLines){
%            if(stereo->diff.StartDiff){
%                stereo->diff.createDiffImage(stereo->imageL_grey[0],stereo->imageL_grey[1]);
%
%                if(stereo->diff.diffImage.data){
%                    stereo->diff.createResAND(stereo->diff.diffImage,stereo->imgThreshold);
%                    stereo->diff.convertToBGR();
%                    stereo->imageL[0].copyTo(stereo->diff.imageL);
%                    stereo->diff.addRedLines();
%
%                    //imshow("imgThreshold",stereo->imgThreshold);
%                    //imshow("DiffImage",stereo->diff.diffImage);
%                    //imshow("Bitwise_AND",stereo->diff.res_AND);
%                }
%
%                stereo->saveLastFrames();
%            }else{
%                stereo->saveLastFrames();
%                stereo->diff.StartDiff=1;
%            }
%        }
%
%        //(9)OpenCV and GUI Output
%        if(stereo->flags.showInputImages){
%            QImage qimageL = putImage(stereo->imageL[0]);
%            QImage qimageR = putImage(stereo->imageR[0]);
%
%            ui->lblOriginalLeft->setPixmap(QPixmap::fromImage(qimageL));
%            ui->lblOriginalRight->setPixmap(QPixmap::fromImage(qimageR));
%        }
%
%        if(stereo->flags.showDisparityMap){
%            QImage qimageL = putImage(stereo->disp.disp_8U);
%            QImage qimageR = putImage(stereo->disp.disp_BGR);
%
%            ui->lblOriginalLeft->setPixmap(QPixmap::fromImage(qimageL));
%            ui->lblOriginalRight->setPixmap(QPixmap::fromImage(qimageR));
%        }
%
%        if(stereo->flags.showTrackingObjectView){
%            QImage qimageL = putImage(stereo->trackingView);
%            QImage qimageR = putImage(stereo->imgThreshold);
%
%            ui->lblOriginalLeft->setPixmap(QPixmap::fromImage(qimageL));
%            ui->lblOriginalRight->setPixmap(QPixmap::fromImage(qimageR));
%        }
%
%        if(stereo->flags.showDiffImage && stereo->diff.StartDiff){
%            this->qimageL = putImage(stereo->diff.diffImage);
%            this->qimageR = putImage(stereo->diff.res_AND);
%
%            ui->lblOriginalLeft->setPixmap(QPixmap::fromImage(qimageL));
%            ui->lblOriginalRight->setPixmap(QPixmap::fromImage(qimageR));
%        }
%
%        if(stereo->flags.showWarningLines && stereo->diff.StartDiff){
%            this->qimageL = putImage(stereo->diff.res_ADD);
%            this->qimageR = putImage(stereo->diff.res_AND_BGR);
%
%            ui->lblOriginalLeft->setPixmap(QPixmap::fromImage(qimageL));
%            ui->lblOriginalRight->setPixmap(QPixmap::fromImage(qimageR));
%        }
%
%        //       // if(showStereoParam && !isStereoParamSetupTrackbarsCreated){
%        //       if(showStereoParam && !isStereoParamSetupTrackbarsCreated){
%        //           isStereoParamSetupTrackbarsCreated=true;
%        //           createTrackbars();
%        //            cout << "oi" << endl;
%        //        }else{
%        //            destroyWindow(trackbarWindowName);
%        //            isStereoParamSetupTrackbarsCreated=false;
%        //        }
%
%        //(10)Shortcuts
%        key = waitKey(1);
%        if(key=='`')
%            printHelp();
%        //        if(key=='1')
%        //            showInputImages = !showInputImages;
%        //        if(key=='2')
%        //            showDisparityMap = !showDisparityMap;
%        //        if(key=='3')
%        //            show3Dreconstruction = !show3Dreconstruction;
%        if(key=='4')
%            stereo->flags.showXYZ = !stereo->flags.showXYZ;
%        if(key=='5')
%            stereo->flags.showFPS = !stereo->flags.showFPS;
%        if(key=='6')
%            stereo->flags.showStereoParamValues = !stereo->flags.showStereoParamValues;
%        if(key=='7')
%            stereo->flags.showDiffImage = !stereo->flags.showDiffImage;
%
%        if(key=='f')
%            stereo->view3D.isSub=stereo->view3D.isSub?false:true;
%        if(key=='h')
%            stereo->view3D.viewpoint.x+=stereo->view3D.step;
%        if(key=='g')
%            stereo->view3D.viewpoint.x-=stereo->view3D.step;
%        if(key=='l')
%            stereo->view3D.viewpoint.y+=stereo->view3D.step;
%        if(key=='k')
%            stereo->view3D.viewpoint.y-=stereo->view3D.step;
%        if(key=='n')
%            stereo->view3D.viewpoint.z+=stereo->view3D.step;
%        if(key=='m')
%            stereo->view3D.viewpoint.z-=stereo->view3D.step;
%
%        if(key=='q')
%            break;
%
%        //(11)Video Loop - If the last frame is reached, reset the capture and the frameCounter
%        frameCounter += 1;
%
%        if(frameCounter == stereo->capR.get(CV_CAP_PROP_FRAME_COUNT)){
%            frameCounter = 0;
%            stereo->capL.set(CV_CAP_PROP_POS_FRAMES,0);
%            stereo->capR.set(CV_CAP_PROP_POS_FRAMES,0);
%        }
%
%        if(1){
%        //if(stereo->flags.showFPS){
%            //cout << "Frames: " << frameCounter << "/" << capR.get(CV_CAP_PROP_FRAME_COUNT) << endl;
%            //cout << "Current time(s): " << current_time << endl;
%            //cout << "FPS: " << (frameCounter/current_time) << endl;
%            fps = (int) (1000/((clock()/1000) - lastTime)); // time stuff
%            lastTime = clock()/1000;
%            //cout << clock() << endl;
%            cout << "FPS: " << fps << endl;
%        }
%    }
%    cout << "END" << endl;
%
%    //return 0;
%}
%
%void MainWindow::printHelp(){
%    //Console Output
%    cout << "-----------------Help Menu-----------------\n"
%         << "Run command line: ./reprojectImageTo3D\n"
%         << "Keys:\n"
%         << "'`' -\tShow Help\n"
%         << "'1' -\tShow L/R Windows\t\t'4' -\tShow XYZ\n"
%         << "'2' -\tShow Disparity Map\t\t'5' -\tShow FPS\n"
%         << "'3' -\tShow 3D Reconstruction\t'6' -\tShow Stereo Parameters\n"
%         << "\n3D Viewer Navigation:\n"
%         << "x-axis:\t'g'/'h' -> +x,-x\n"
%         << "y-axis:\t'l'/'k' -> +y,-y\n"
%         << "z-axis:\t'n'/'m' -> +z,-z\n"
%         << "-------------------------------------------\n"
%         << "\n\n";
%
%    //GUI
%    ui->txtOutputBox->appendPlainText
%            (QString("-----------------Help Menu-----------------\n")+
%             QString("Run command line: ./reprojectImageTo3D\n")+
%             QString("Keys:\n")+
%             QString("'`' -\tShow Help\n")+
%             QString("'1' -\tShow L/R Windows\t\t'4' -\tShow XYZ\n")+
%             QString("'2' -\tShow Disparity Map\t\t'5' -\tShow FPS\n")+
%             QString("'3' -\tShow 3D Reconstruction\t'6' -\tShow Stereo Parameters\n")+
%             QString("\n3D Viewer Navigation:\n")+
%             QString("x-axis:\t'g'/'h' -> +x,-x\n")+
%             QString("y-axis:\t'l'/'k' -> +y,-y\n")+
%             QString("z-axis:\t'n'/'m' -> +z,-z\n")+
%             QString("-------------------------------------------\n")+
%             QString("\n\n"));
%}
%
%void MainWindow::openStereoSource(int inputNum){
%    string imageL_filename;
%    string imageR_filename;
%
%    // Create an object that decodes the input Video stream.
%    cout << "Enter Video Number(1,2,3,4,5,6,7,8,9): " << endl;
%    ui->txtOutputBox->appendPlainText(QString("Enter Video Number(1,2,3,4,5,6,7,8,9): "));
%    //	scanf("%d",&inputNum);
%    cout << "Input File: " << inputNum << endl;
%    ui->txtOutputBox->appendPlainText(QString("Input File: ")+QString::number(inputNum));
%    switch(inputNum){
%    case 1:
%        imageL_filename = "../../workspace/data/video10_l.avi";
%        imageR_filename = "../../workspace/data/video10_r.avi";
%        needCalibration=true;
%        //ui->txtOutputBox->appendPlainText(QString("video2_denoised_long.avi"));
%        break;
%    case 2:
%        imageL_filename = "../../workspace/data/video12_l.avi";
%        imageR_filename = "../../workspace/data/video12_r.avi";
%        needCalibration=true;
%        //ui->txtOutputBox->appendPlainText(QString( "video0.avi"));
%        break;
%    case 3:
%        imageL_filename = "../data/left/video1.avi";
%        imageR_filename = "../data/right/video1.avi";
%        needCalibration=true;
%        //ui->txtOutputBox->appendPlainText(QString( "video1.avi"));
%        break;
%    case 4:
%        imageL_filename = "../data/left/video2_noised.avi";
%        imageR_filename = "../data/right/video2_noised.avi";
%        needCalibration=true;
%        //ui->txtOutputBox->appendPlainText(QString( "video2_noised.avi"));
%        break;
%    case 5:
%        imageL_filename = "../data/left/20004.avi";
%        imageR_filename = "../data/right/30004.avi";
%        needCalibration=false;
%        break;
%    case 6:
%        imageL_filename = "../../workspace/data/left/video15.avi";
%        imageR_filename = "../../workspace/data/right/video15.avi";
%        needCalibration=true;
%        break;
%    case 7:
%        imageL_filename = "../../workspace/data/left/left1.png";
%        imageR_filename = "../../workspace/data/right/right1.png";
%        needCalibration=false;
%        break;
%    case 8:
%        imageL_filename = "../data/left/left2.png";
%        imageR_filename = "../data/right/right2.png";
%        needCalibration=false;
%        break;
%    case 9:
%        imageL_filename = "../data/left/left3.png";
%        imageR_filename = "../data/right/right3.png";
%        needCalibration=false;
%        break;
%    }
%
%    if(imageL_filename.substr(imageL_filename.find_last_of(".") + 1) == "avi"){
%        cout << "It's a Video file" << endl;
%        ui->txtOutputBox->appendPlainText(QString("It's a Video file"));
%        isVideoFile=true;
%
%        stereo->capL.open(imageL_filename);
%        stereo->capR.open(imageR_filename);
%
%        if(!stereo->capL.isOpened() || !stereo->capR.isOpened()){		// Check if we succeeded
%            cerr <<  "Could not open or find the input videos!" << endl ;
%            ui->txtOutputBox->appendPlainText(QString( "Could not open or find the input videos!"));
%            //return -1;
%        }
%
%        cout << "Input 1 Resolution: " << stereo->capR.get(CV_CAP_PROP_FRAME_WIDTH) << "x" << stereo->capR.get(CV_CAP_PROP_FRAME_HEIGHT) << endl;
%        cout << "Input 2 Resolution: " << stereo->capL.get(CV_CAP_PROP_FRAME_WIDTH) << "x" << stereo->capL.get(CV_CAP_PROP_FRAME_HEIGHT) << endl << endl;
%        ui->txtOutputBox->appendPlainText(QString("Input 1 Resolution: ") + QString::number(stereo->capL.get(CV_CAP_PROP_FRAME_WIDTH)) + QString("x") + QString::number(stereo->capL.get(CV_CAP_PROP_FRAME_HEIGHT)));
%        ui->txtOutputBox->appendPlainText(QString("Input 2 Resolution: ") + QString::number(stereo->capR.get(CV_CAP_PROP_FRAME_WIDTH)) + QString("x") + QString::number(stereo->capR.get(CV_CAP_PROP_FRAME_HEIGHT)));
%    }else{
%        cout << "It is not a Video file" << endl;
%        ui->txtOutputBox->appendPlainText(QString( "It is not a Video file"));
%        if(imageL_filename.substr(imageL_filename.find_last_of(".") + 1) == "jpg" || imageL_filename.substr(imageL_filename.find_last_of(".") + 1) == "png"){
%            cout << "It's a Image file" << endl;
%            ui->txtOutputBox->appendPlainText(QString( "It's a Image file"));
%            isImageFile=true;
%
%            stereo->imageL[0] = imread(imageL_filename, CV_LOAD_IMAGE_COLOR);	// Read the file
%            stereo->imageR[0] = imread(imageR_filename, CV_LOAD_IMAGE_COLOR);	// Read the file
%
%            if(!stereo->imageL[0].data || !stereo->imageR[0].data){                     // Check for invalid input
%                ui->txtOutputBox->appendPlainText(QString("Could not open or find the input images!"));
%                return;
%            }
%        }else{
%            cout << "It is not a Image file" << endl;
%            ui->txtOutputBox->appendPlainText(QString( "It is not a Image file"));
%        }
%    }
%}
%
%void MainWindow::on_btnShowInputImages_clicked(){
%    this->stereo->flags.showInputImages = true;
%    this->stereo->flags.showDisparityMap = false;
%    this->stereo->flags.show3Dreconstruction = false;
%    this->stereo->flags.showTrackingObjectView = false;
%    this->stereo->flags.showDiffImage = false;
%    this->stereo->flags.showWarningLines = false;
%}
%
%void MainWindow::on_btnShowDisparityMap_clicked(){
%    this->stereo->flags.showInputImages = false;
%    this->stereo->flags.showDisparityMap = true;
%    this->stereo->flags.show3Dreconstruction = false;
%    this->stereo->flags.showTrackingObjectView = false;
%    this->stereo->flags.showDiffImage = false;
%    this->stereo->flags.showWarningLines = false;
%}
%
%void MainWindow::on_btnShow3DReconstruction_clicked(){
%    this->stereo->flags.showInputImages = false;
%    this->stereo->flags.showDisparityMap = false;
%    this->stereo->flags.show3Dreconstruction = true;
%    this->stereo->flags.showTrackingObjectView = false;
%    this->stereo->flags.showDiffImage = false;
%    this->stereo->flags.showWarningLines = false;
%}
%
%void MainWindow::on_btnShowTrackingObjectView_clicked(){
%    this->stereo->flags.showInputImages = false;
%    this->stereo->flags.showDisparityMap = false;
%    this->stereo->flags.show3Dreconstruction = false;
%    this->stereo->flags.showTrackingObjectView = true;
%    this->stereo->flags.showDiffImage = false;
%    this->stereo->flags.showWarningLines = false;
%}
%
%void MainWindow::on_btnShowDiffImage_clicked(){
%    this->stereo->flags.showInputImages = false;
%    this->stereo->flags.showDisparityMap = false;
%    this->stereo->flags.show3Dreconstruction = false;
%    this->stereo->flags.showTrackingObjectView = false;
%    this->stereo->flags.showDiffImage = true;
%    this->stereo->flags.showWarningLines = false;
%}
%
%void MainWindow::on_btnShowDiffImage_2_clicked(){
%    this->stereo->flags.showInputImages = false;
%    this->stereo->flags.showDisparityMap = false;
%    this->stereo->flags.show3Dreconstruction = false;
%    this->stereo->flags.showTrackingObjectView = false;
%    this->stereo->flags.showDiffImage = false;
%    this->stereo->flags.showWarningLines = true;
%}
%
%QImage MainWindow::putImage(const Mat& mat){
%    // 8-bits unsigned, NO. OF CHANNELS=1
%    if(mat.type()==CV_8UC1)
%    {
%        // Set the color table (used to translate colour indexes to qRgb values)
%        QVector<QRgb> colorTable;
%        for (int i=0; i<256; i++)
%            colorTable.push_back(qRgb(i,i,i));
%        // Copy input Mat
%        const uchar *qImageBuffer = (const uchar*)mat.data;
%        // Create QImage with same dimensions as input Mat
%        QImage img(qImageBuffer, mat.cols, mat.rows, mat.step, QImage::Format_Indexed8);
%        img.setColorTable(colorTable);
%        return img;
%    }
%    // 8-bits unsigned, NO. OF CHANNELS=3
%    if(mat.type()==CV_8UC3)
%    {
%        // Copy input Mat
%        const uchar *qImageBuffer = (const uchar*)mat.data;
%        // Create QImage with same dimensions as input Mat
%        QImage img(qImageBuffer, mat.cols, mat.rows, mat.step, QImage::Format_RGB888);
%        return img.rgbSwapped();
%    }
%    else
%    {
%        qDebug() << "ERROR: Mat could not be converted to QImage.";
%        return QImage();
%    }
%}
%
%void writeMatToFile(cv::Mat& m, const char* filename)
%{
%    ofstream fout(filename);
%
%    if(!fout)
%    {
%        cout<<"File Not Opened"<<endl;  return;
%    }
%
%    for(int i=0; i<m.rows; i++)
%    {
%        for(int j=0; j<m.cols; j++)
%        {
%            fout<<m.at<float>(i,j)<<"\t";
%        }
%        fout<<endl;
%    }
%
%    fout.close();
%}
%
%void MainWindow::createTrackbars(){ //Create Window for trackbars
%    char TrackbarName[50];
%
%    // Create TrackBars Window
%    namedWindow(trackbarWindowName,0);
%
%    // Create memory to store Trackbar name on window
%    sprintf( TrackbarName, "preFilterSize");
%    sprintf( TrackbarName, "preFilterCap");
%    sprintf( TrackbarName, "SADWindowSize");
%    sprintf( TrackbarName, "minDisparity");
%    sprintf( TrackbarName, "numberOfDisparities");
%    sprintf( TrackbarName, "textureThreshold");
%    sprintf( TrackbarName, "uniquenessRatio");
%    sprintf( TrackbarName, "speckleWindowSize");
%    sprintf( TrackbarName, "speckleRange");
%    sprintf( TrackbarName, "disp12MaxDiff");
%
%    //Create Trackbars and insert them into window
%
%
%    createTrackbar( "preFilterSize", trackbarWindowName, &this->stereo->stereocfg.preFilterSize, preFilterSize_MAX, on_trackbar );
%    createTrackbar( "preFilterCap", trackbarWindowName, &this->stereo->stereocfg.preFilterCap, preFilterCap_MAX, on_trackbar );
%    createTrackbar( "SADWindowSize", trackbarWindowName, &this->stereo->stereocfg.SADWindowSize, SADWindowSize_MAX, on_trackbar );
%    createTrackbar( "minDisparity", trackbarWindowName, &this->stereo->stereocfg.minDisparity, minDisparity_MAX, on_trackbar );
%    createTrackbar( "numberOfDisparities", trackbarWindowName, &this->stereo->stereocfg.numberOfDisparities, numberOfDisparities_MAX, on_trackbar );
%    createTrackbar( "textureThreshold", trackbarWindowName, &this->stereo->stereocfg.textureThreshold, textureThreshold_MAX, on_trackbar );
%    createTrackbar( "uniquenessRatio", trackbarWindowName, &this->stereo->stereocfg.uniquenessRatio, uniquenessRatio_MAX, on_trackbar );
%    createTrackbar( "speckleWindowSize", trackbarWindowName, &this->stereo->stereocfg.speckleWindowSize, speckleWindowSize_MAX, on_trackbar );
%    createTrackbar( "speckleRange", trackbarWindowName, &this->stereo->stereocfg.speckleRange, speckleRange_MAX, on_trackbar );
%    createTrackbar( "disp12MaxDiff", trackbarWindowName, &this->stereo->stereocfg.disp12MaxDiff, disp12MaxDiff_MAX, on_trackbar );
%}
%
%void on_trackbar(int,void*){}; //This function gets called whenever a trackbar position is changed
%
%void resizeFrames(Mat* frame1,Mat* frame2){
%    if(frame1->cols != 0 || !frame2->cols != 0){
%#ifdef RESOLUTION_320x240
%        resize(*frame1, *frame1, Size(320,240), 0, 0, INTER_CUBIC);
%        resize(*frame2, *frame2, Size(320,240), 0, 0, INTER_CUBIC);
%#endif
%
%#ifdef RESOLUTION_640x480
%        resize(*frame1, *frame1, Size(640,480), 0, 0, INTER_CUBIC);
%        resize(*frame2, *frame2, Size(640,480), 0, 0, INTER_CUBIC);
%#endif
%
%#ifdef RESOLUTION_1280x720
%        resize(*frame1, *frame1, Size(1280,720), 0, 0, INTER_CUBIC);
%        resize(*frame2, *frame2, Size(1280,720), 0, 0, INTER_CUBIC);
%#endif
%    }
%}
%
%void change_resolution(VideoCapture* capL,VideoCapture* capR){
%#ifdef RESOLUTION_320x240
%    capL->set(CV_CAP_PROP_FRAME_WIDTH, 320);
%    capL->set(CV_CAP_PROP_FRAME_HEIGHT,240);
%    capR->set(CV_CAP_PROP_FRAME_WIDTH, 320);
%    capR->set(CV_CAP_PROP_FRAME_HEIGHT,240);
%#endif
%
%#ifdef RESOLUTION_640x480
%    capL->set(CV_CAP_PROP_FRAME_WIDTH, 640);
%    capL->set(CV_CAP_PROP_FRAME_HEIGHT,480);
%    capR->set(CV_CAP_PROP_FRAME_WIDTH, 640);
%    capR->set(CV_CAP_PROP_FRAME_HEIGHT,480);
%#endif
%
%#ifdef RESOLUTION_1280x960
%    capL->set(CV_CAP_PROP_FRAME_WIDTH,1280);
%    capL->set(CV_CAP_PROP_FRAME_HEIGHT,720);
%    capR->set(CV_CAP_PROP_FRAME_WIDTH,1280);
%    capR->set(CV_CAP_PROP_FRAME_HEIGHT,720);
%#endif
%
%    cout << "Camera 1 Resolution: " << capL->get(CV_CAP_PROP_FRAME_WIDTH) << "x" << capL->get(CV_CAP_PROP_FRAME_HEIGHT) << endl;
%    cout << "Camera 2 Resolution: " << capR->get(CV_CAP_PROP_FRAME_WIDTH) << "x" << capR->get(CV_CAP_PROP_FRAME_HEIGHT) << endl;
%}
%
%void imageProcessing1(Mat Image, Mat MedianImage, Mat MedianImageBGR){
%
%    // Apply Median Filter
%    medianBlur(Image,MedianImage,5);
%    applyColorMap(MedianImage,MedianImageBGR, COLORMAP_JET);
%
%    // Output
%    imshow("Disparity Map Median Filter 3x3",MedianImage);
%    imshow("Disparity Map Median Filter 3x3 - RGB",MedianImageBGR);
%}
%
%void contrast_and_brightness(Mat &left,Mat &right,float alpha,float beta){
%    //Contrast and Brightness. Do the operation: new_image(i,j) = alpha*image(i,j) + beta
%    for( int y = 0; y < left.rows; y++ ){
%        for( int x = 0; x < left.cols; x++ ){
%            for( int c = 0; c < 3; c++ ){
%                left .at<Vec3b>(y,x)[c] = saturate_cast<uchar>( alpha*( left .at<Vec3b>(y,x)[c] ) + beta );
%                right.at<Vec3b>(y,x)[c] = saturate_cast<uchar>( alpha*( right.at<Vec3b>(y,x)[c] ) + beta );
%            }
%        }
%    }
%}
%\end{lstlisting}
%
%\textbf{setstereoparams.cpp}
%\begin{lstlisting}
%/*
% * setstereoparams.cpp
% *
% *  Created on: Oct 1, 2015
% *      Author: nicolasrosa
% */
%#include "setstereoparams.h"
%#include "ui_setstereoparams.h"
%#include "iostream"
%#include "StereoProcessor.h"
%
%#include <QHBoxLayout>
%#include <QSlider>
%#include <QSpinBox>
%
%//using namespace cv;
%using namespace std;
%
%SetStereoParams::SetStereoParams(QWidget *parent, StereoProcessor *stereo) : QDialog(parent), ui(new Ui::SetStereoParams){
%    ui->setupUi(this);
%    //stereocfg_pointer = &stereocfg;
%
%    this->stereo = stereo;
%
%    connect(ui->preFilterSize_slider, SIGNAL(valueChanged(int)),ui->preFilterSize_spinBox,SLOT(setValue(int)));
%    connect(ui->preFilterCap_slider, SIGNAL(valueChanged(int)),ui->preFilterCap_spinBox,SLOT(setValue(int)));
%    connect(ui->SADWindowSize_slider, SIGNAL(valueChanged(int)),ui->SADWindowSize_spinBox,SLOT(setValue(int)));
%    connect(ui->minDisparity_slider, SIGNAL(valueChanged(int)),ui->minDisparity_spinBox,SLOT(setValue(int)));
%    connect(ui->numberOfDisparities_slider, SIGNAL(valueChanged(int)),ui->numberOfDisparities_spinBox,SLOT(setValue(int)));
%    connect(ui->textureThreshold_slider, SIGNAL(valueChanged(int)),ui->textureThreshold_spinBox,SLOT(setValue(int)));
%    connect(ui->uniquenessRatio_slider, SIGNAL(valueChanged(int)),ui->uniquenessRatio_spinBox,SLOT(setValue(int)));
%    connect(ui->speckleWindowSize_slider, SIGNAL(valueChanged(int)),ui->speckleWindowSize_spinBox,SLOT(setValue(int)));
%    connect(ui->speckleRange_slider, SIGNAL(valueChanged(int)),ui->speckleRange_spinBox,SLOT(setValue(int)));
%    connect(ui->disp12MaxDiff_slider, SIGNAL(valueChanged(int)),ui->disp12MaxDiff_spinBox,SLOT(setValue(int)));
%    connect(ui->preFilterSize_spinBox, SIGNAL(valueChanged(int)),ui->preFilterSize_slider,SLOT(setValue(int)));
%    connect(ui->preFilterCap_spinBox, SIGNAL(valueChanged(int)),ui->preFilterCap_slider,SLOT(setValue(int)));
%    connect(ui->SADWindowSize_spinBox, SIGNAL(valueChanged(int)),ui->SADWindowSize_slider,SLOT(setValue(int)));
%    connect(ui->minDisparity_spinBox, SIGNAL(valueChanged(int)),ui->minDisparity_slider,SLOT(setValue(int)));
%    connect(ui->numberOfDisparities_spinBox, SIGNAL(valueChanged(int)),ui->numberOfDisparities_slider,SLOT(setValue(int)));
%    connect(ui->textureThreshold_spinBox, SIGNAL(valueChanged(int)),ui->textureThreshold_slider,SLOT(setValue(int)));
%    connect(ui->uniquenessRatio_spinBox, SIGNAL(valueChanged(int)),ui->uniquenessRatio_slider,SLOT(setValue(int)));
%    connect(ui->speckleWindowSize_spinBox, SIGNAL(valueChanged(int)),ui->speckleWindowSize_slider,SLOT(setValue(int)));
%    connect(ui->speckleRange_spinBox, SIGNAL(valueChanged(int)),ui->speckleRange_slider,SLOT(setValue(int)));
%    connect(ui->disp12MaxDiff_spinBox, SIGNAL(valueChanged(int)),ui->disp12MaxDiff_slider,SLOT(setValue(int)));
%}
%
%//Ui::SetStereoParams* SetStereoParams::getUi(){
%//    return(this->ui);
%//}
%
%void SetStereoParams::loadStereoParamsUi(int preFilterSize,int preFilterCap,int SADWindowSize,int minDisparity,int numberOfDisparities,int textureThreshold,int uniquenessRatio, int speckleWindowSize, int speckleRange,int disp12MaxDiff){
%    this->ui->preFilterSize_slider->setValue(preFilterSize);
%    this->ui->preFilterSize_spinBox->setValue(preFilterSize);
%
%    this->ui->preFilterCap_slider->setValue(preFilterCap);
%    this->ui->preFilterCap_spinBox->setValue(preFilterCap);
%
%    this->ui->SADWindowSize_slider->setValue(SADWindowSize);
%    this->ui->SADWindowSize_spinBox->setValue(SADWindowSize);
%
%    this->ui->minDisparity_slider->setValue(minDisparity);
%    this->ui->minDisparity_spinBox->setValue(minDisparity);
%
%    this->ui->numberOfDisparities_slider->setValue(numberOfDisparities);
%    this->ui->numberOfDisparities_spinBox->setValue(numberOfDisparities);
%
%    this->ui->textureThreshold_slider->setValue(textureThreshold);
%    this->ui->textureThreshold_spinBox->setValue(textureThreshold);
%
%    this->ui->uniquenessRatio_slider->setValue(uniquenessRatio);
%    this->ui->uniquenessRatio_spinBox->setValue(uniquenessRatio);
%
%    this->ui->speckleWindowSize_slider->setValue(speckleWindowSize);
%    this->ui->speckleWindowSize_spinBox->setValue(speckleWindowSize);
%
%    this->ui->speckleRange_slider->setValue(speckleRange);
%    this->ui->speckleRange_spinBox->setValue(speckleRange);
%
%    this->ui->disp12MaxDiff_slider->setValue(disp12MaxDiff);
%    this->ui->disp12MaxDiff_spinBox->setValue(disp12MaxDiff);
%}
%
%//void SetStereoParams::getStereoParamsUi(){
%
%//}
%
%SetStereoParams::~SetStereoParams()
%{
%    delete ui;
%}
%
%/* Sliders */
%void SetStereoParams::on_preFilterSize_slider_valueChanged(int value)
%{
%    cout << "Bar1: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_preFilterCap_slider_valueChanged(int value)
%{
%    cout << "Bar2: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_SADWindowSize_slider_valueChanged(int value)
%{
%    cout << "Bar3: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_minDisparity_slider_valueChanged(int value)
%{
%    cout << "Bar4: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_numberOfDisparities_slider_valueChanged(int value)
%{
%    cout << "Bar5: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_textureThreshold_slider_valueChanged(int value)
%{
%    cout << "Bar6: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_uniquenessRatio_slider_valueChanged(int value)
%{
%    cout << "Bar7: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_speckleWindowSize_slider_valueChanged(int value)
%{
%    cout << "Bar8: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_speckleRange_slider_valueChanged(int value)
%{
%    cout << "Bar9: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_disp12MaxDiff_slider_valueChanged(int value)
%{
%    cout << "Bar10: " << value << endl;
%    updateValues();
%}
%
%/* SpinBoxes */
%void SetStereoParams::on_preFilterSize_spinBox_valueChanged(int value)
%{
%    cout << "Spin1: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_preFilterCap_spinBox_valueChanged(int value)
%{
%    cout << "Spin2: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_SADWindowSize_spinBox_valueChanged(int value)
%{
%    cout << "Spin3: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_minDisparity_spinBox_valueChanged(int value)
%{
%    cout << "Spin4: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_numberOfDisparities_spinBox_valueChanged(int value)
%{
%    cout << "Spin5: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_textureThreshold_spinBox_valueChanged(int value)
%{
%    cout << "Spin6: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_uniquenessRatio_spinBox_valueChanged(int value)
%{
%    cout << "Spin7: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_speckleWindowSize_spinBox_valueChanged(int value)
%{
%    cout << "Spin8: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_speckleRange_spinBox_valueChanged(int value)
%{
%    cout << "Spin9: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_disp12MaxDiff_spinBox_valueChanged(int value)
%{
%    cout << "Spin10: " << value << endl;
%    updateValues();
%}
%
%void SetStereoParams::on_buttonBox_accepted(){
%
%}
%
%void SetStereoParams::on_buttonBox_rejected(){
%
%}
%
%void SetStereoParams::updateValues() {
%
%    std::cout << "UPDATE VALUES!\n";
%    stereo->setValues(ui->preFilterSize_slider->value(),
%                      ui->preFilterCap_slider->value(),
%                      ui->SADWindowSize_slider->value(),
%                      ui->minDisparity_slider->value(),
%                      ui->numberOfDisparities_slider->value(),
%                      ui->textureThreshold_slider->value(),
%                      ui->uniquenessRatio_slider->value(),
%                      ui->speckleWindowSize_slider->value(),
%                      ui->speckleRange_slider->value(),
%                      ui->disp12MaxDiff_slider->value());
%
%    this->stereo->setStereoParams();
%}
%\end{lstlisting}
%
%\textbf{StereoCalib.cpp}
%\begin{lstlisting}
%/*
% * StereoCalib.cpp
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#include "StereoCalib.h"
%
%/* Constructor */
%StereoCalib::StereoCalib(){}
%
%void StereoCalib::createKMatrix(){
%    this->K=Mat::eye(3,3,CV_64F);
%    this->K.at<double>(0,0)=this->focalLength;
%    this->K.at<double>(1,1)=this->focalLength;
%    //this->K.at<double>(0,2)=(this->imageSize.width-1.0)/2.0;
%    //this->K.at<double>(1,2)=(this->imageSize.height-1.0)/2.0;
%    this->K.at<double>(0,2)=(0-1.0)/2.0;
%    this->K.at<double>(1,2)=(0-1.0)/2.0;
%    cout << "K:" << endl << this->K << endl;
%}
%
%/*** Read Q Matrix function
%  ** Description: Reads the Q Matrix in the *.yml file
%  ** Receives:    Matrices Addresses for storage
%  ** Returns:     Nothing
%  **
%  ** Perspective transformation matrix(Q)
%  ** [ 1  0    0	   -cx     ]
%  ** [ 0  1    0 	   -cy     ]
%  ** [ 0  0    0		f      ]
%  ** [ 0  0  -1/Tx 	(cx-cx')/Tx]
%  ***/
%void StereoCalib::readQMatrix(){
%    FileStorage fs(this->QmatrixFileName, FileStorage::READ);
%
%    if(this->is640x480){
%        if(!fs.isOpened()){
%            cerr << "Failed to open Q.yml file" << endl;
%            return;
%        }
%
%        fs["Q"] >> this->Q;
%        // Check
%        if(!this->Q.data){
%            cerr << "Check Q Matrix Content!" << endl;
%            return;
%        }
%
%        // Display
%        cout << "Q:" << endl << this->Q << endl;
%
%        this->focalLength = this->Q.at<double>(2,3);  cout << "f:" << this->focalLength << endl;
%        this->baseline = -1.0/this->Q.at<double>(3,2); cout << "baseline: " << this->baseline << endl;
%    }else{
%        cerr << "Check Q.yml file!\n" << endl;
%        return;
%    }
%}
%
%void StereoCalib::calculateQMatrix(){
%    this->Q = Mat::eye(4,4,CV_64F);
%    this->Q.at<double>(0,3)=-this->imageCenter.x;
%    this->Q.at<double>(1,3)=-this->imageCenter.y;
%    this->Q.at<double>(2,3)=this->focalLength;
%    this->Q.at<double>(3,3)=0.0;
%    this->Q.at<double>(2,2)=0.0;
%    this->Q.at<double>(3,2)=1.0/this->baseline;
%    cout << "Q:" << endl << this->Q << endl;
%}
%\end{lstlisting}
%
%\textbf{StereoConfig.cpp}
%\begin{lstlisting}
%/*
% * StereoConfig.cpp
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#include "StereoConfig.h"
%
%/* Constructor */
%StereoConfig::StereoConfig(){}
%\end{lstlisting}
%
%\textbf{StereoCustom.h}
%\begin{lstlisting}
%/*
% * StereoCustom.h
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#include "StereoCustom.h"
%\end{lstlisting}
%
%\textbf{StereoDiff.cpp}
%\begin{lstlisting}
%/*
% * StereoDiff.cpp
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#include "StereoDiff.h"
%
%/* Constructor */
%StereoDiff::StereoDiff(){
%    StartDiff=false;
%    alpha = 0.5;
%    beta = (1.0-alpha);
%}
%
%void StereoDiff::createDiffImage(Mat input1, Mat input2){
%    absdiff(input1,input2,diffImage);
%}
%
%void StereoDiff::createResAND(Mat input1,Mat input2){
%    bitwise_and(input1,input2,this->res_AND);
%}
%
%void StereoDiff::convertToBGR(){
%    cvtColor(res_AND,res_AND_BGR,CV_GRAY2BGR);
%}
%
%void StereoDiff::addRedLines(){
%    split(res_AND_BGR,res_AND_BGR_channels);
%
%    //Set the Blue and Green Channels to 0
%    res_AND_BGR_channels[0] = Mat::zeros(res_AND.rows,res_AND.cols,CV_8UC1);
%    res_AND_BGR_channels[1] = Mat::zeros(res_AND.rows,res_AND.cols,CV_8UC1);
%    cv::merge(res_AND_BGR_channels,3,res_AND_BGR);
%
%    addWeighted(this->imageL,alpha,res_AND_BGR,beta, 0.0,res_ADD);
%
%    //imshow("Add",res_ADD);
%}
%\end{lstlisting}
%
%\textbf{StereoDisparityMap.cpp}
%\begin{lstlisting}
%/*
% * StereoDisparityMap.cpp
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#include "StereoDisparityMap.h"
%
%/* Constructor */
%StereoDisparityMap::StereoDisparityMap(){
%    // Allocate Memory
%    //Mat disp     = Mat(imageR[0].rows, imageR[0].cols, CV_16UC1);
%    //Mat disp_8U  = Mat(stereo->imageR[0].rows, stereo->imageR[0].cols, CV_8UC1);
%    //Mat disp_BGR = Mat(stereo->imageR[0].rows, stereo->imageR[0].cols, CV_8UC3);
%}
%\end{lstlisting}
%
%\textbf{StereoFlags.cpp}
%\begin{lstlisting}
%/*
% * StereoFlags.cpp
% *
% *  Created on: Dec 3, 2015
% *      Author: nicolasrosa
% */
%
%#include "StereoFlags.h"
%
%/* Constructor */
%StereoFlags::StereoFlags(){
%    showInputImages=true;
%    showXYZ=false;
%    showStereoParam=false;
%    showStereoParamValues=false;
%    showFPS=false;
%    showDisparityMap=false;
%    show3Dreconstruction=false;
%    showTrackingObjectView=false;
%    showDiffImage=false;
%    showWarningLines=false;
%}
%\end{lstlisting}
%
%\textbf{StereoProcessor.cpp}
%\begin{lstlisting}
%/*
% * StereoProcessor.cpp
% *
% *  Created on: Oct 20, 2015
% *      Author: nicolasrosa
% */
%
%#include "trackObject.h"
%
%/* Constructor */
%#include "StereoProcessor.h"
%
%StereoProcessor::StereoProcessor(int number) {
%    inputNum=number;
%}
%
%int StereoProcessor::getInputNum(){
%    return inputNum;
%}
%
%void StereoProcessor::readConfigFile(){
%    //FileStorage fs("../reprojectImageTo3D_calibON_bm_GUI/config.yml", FileStorage::READ);
%    FileStorage fs("/home/nicolas/repository/StereoVision/Qt Creator/reprojectImageTo3D_calibON_bm_GUI/config.yml", FileStorage::READ);
%
%    if(!fs.isOpened()){
%        cerr << "Failed to open config.yml file!" << endl;
%        return;
%    }
%    fs["Intrinsics Path"] >> this->calib.intrinsicsFileName;
%    fs["Extrinsics Path"] >> this->calib.extrinsicsFileName;
%    fs["Q Matrix Path"]   >> this->calib.QmatrixFileName;
%    fs["Stereo Parameters Path"] >> this->calib.StereoParamFileName;
%
%    fs.release();
%
%    cout << "------------------------------Config.yml------------------------------" << endl;
%    cout << "Intrinsics Path: "         << this->calib.intrinsicsFileName  << endl;
%    cout << "Extrinsics Path: "         << this->calib.extrinsicsFileName  << endl;
%    cout << "Q Matrix Path: "           << this->calib.QmatrixFileName     << endl;
%    cout << "Stereo Parameters Path:"   << this->calib.StereoParamFileName << endl;
%    cout << "Config.yml Read Successfully." << endl << endl ;
%    cout << "----------------------------------------------------------------------" << endl;
%}
%
%void StereoProcessor::readStereoConfigFile(){
%    FileStorage fs(this->calib.StereoParamFileName, FileStorage::READ);
%    if(!fs.isOpened()){
%        cerr << "Failed to open stereo.yml file!" << endl;
%        return;
%    }
%
%    fs["preFilterSize"] >> this->stereocfg.preFilterSize;
%    fs["preFilterCap"] >> this->stereocfg.preFilterCap;
%    fs["SADWindowSize"] >> this->stereocfg.SADWindowSize;
%    fs["minDisparity"] >> this->stereocfg.minDisparity;
%    fs["numberOfDisparities"] >> this->stereocfg.numberOfDisparities;
%    fs["textureThreshold"] >> this->stereocfg.textureThreshold;
%    fs["uniquenessRatio"] >> this->stereocfg.uniquenessRatio;
%    fs["speckleWindowSize"] >> this->stereocfg.speckleWindowSize;
%    fs["speckleRange"] >> this->stereocfg.speckleRange;
%    fs["disp12MaxDiff"] >> this->stereocfg.disp12MaxDiff;
%
%    fs.release();
%
%    // Display
%    cout << "------------------------------StereoConfig----------------------------" << endl;
%    cout << "preFilterSize: "       << this->stereocfg.preFilterSize          << endl;
%    cout << "preFilterCap: "        << this->stereocfg.preFilterCap           << endl;
%    cout << "SADWindowSize: "       << this->stereocfg.SADWindowSize          << endl;
%    cout << "minDisparity: "        << this->stereocfg.minDisparity           << endl;
%    cout << "numberOfDisparities: " << this->stereocfg.numberOfDisparities    << endl;
%    cout << "textureThreshold: "    << this->stereocfg.textureThreshold       << endl;
%    cout << "uniquenessRatio: "     << this->stereocfg.uniquenessRatio        << endl;
%    cout << "speckleWindowSize: "   << this->stereocfg.speckleWindowSize      << endl;
%    cout << "speckleRange: "        << this->stereocfg.speckleRange           << endl;
%    cout << "disp12MaxDiff: "       << this->stereocfg.disp12MaxDiff          << endl;
%    cout << "stereo.yml Read Successfully."  << endl << endl;
%    cout << "----------------------------------------------------------------------" << endl << endl;
%}
%
%/*** Stereo Initialization function
%  ** Description: Executes the PreSetup of parameters of the StereoBM object
%  ** @param StereoBM bm: Correspondence Object
%  ** Returns:     Nothing
%  ***/
%void StereoProcessor::stereoInit(){
%    this->bm->setPreFilterCap(31);
%    this->bm->setBlockSize(25 > 0 ? 25 : 9);
%    this->bm->setMinDisparity(0);
%    this->bm->setNumDisparities(3);
%    this->bm->setTextureThreshold(10);
%    this->bm->setUniquenessRatio(15);
%    this->bm->setSpeckleWindowSize(100);
%    this->bm->setSpeckleRange(32);
%    this->bm->setDisp12MaxDiff(1);
%}
%
%/*** Stereo Calibration function
%  ** Description: Reads the Calibrations in *.yml files
%  ** Receives:    Matrices Addresses for storage
%  ** @param Mat M1,M2: Intrinsic Matrices from camera 1 and 2
%  ** @param Mat D1,D2: Distortion Coefficients from camera 1 and 2
%  ** @param Mat R: Rotation Matrix
%  ** @param Mat t: Translation Vector
%  ** Returns:     Nothing
%  ***/
%void StereoProcessor::stereoCalib(){
%    FileStorage fs(this->calib.intrinsicsFileName, FileStorage::READ);
%    if(!fs.isOpened()){
%        cerr << "Failed to open intrinsics.yml file!" << endl;
%        return;
%    }
%
%    fs["M1"] >> this->calib.M1;
%    fs["D1"] >> this->calib.D1;
%    fs["M2"] >> this->calib.M2;
%    fs["D2"] >> this->calib.D2;
%
%    fs.release();
%
%    float scale = 1.f;
%    this->calib.M1 *= scale;
%    this->calib.M2 *= scale;
%
%    fs.open(this->calib.extrinsicsFileName, FileStorage::READ);
%    if(!fs.isOpened()){
%        cerr << "Failed to open extrinsics.yml file!" << endl;
%        return;
%    }
%
%    fs["R"] >> this->calib.R;
%    fs["T"] >> this->calib.T;
%
%    fs.release();
%
%    // Check
%    if(!this->calib.M1.data || !this->calib.D1.data || !this->calib.M2.data || !this->calib.D2.data || !this->calib.R.data || !this->calib.T.data){
%        cerr << "Check instrinsics and extrinsics Matrixes content!" << endl;
%        return;
%    }
%
%    // Display
%    cout << "------------------------------Intrinsics------------------------------" << endl;
%    cout << "M1: " << endl << this->calib.M1 << endl;
%    cout << "D1: " << endl << this->calib.D1 << endl;
%    cout << "M2: " << endl << this->calib.M2 << endl;
%    cout << "D2: " << endl << this->calib.D2 << endl << endl;
%    cout << "intrinsics.yml Read Successfully."  << endl << endl;
%
%    cout << "------------------------------Extrinsics------------------------------" << endl;
%    cout << "R: " << endl << this->calib.R << endl;
%    cout << "T: " << endl << this->calib.T << endl << endl;
%    cout << "extrinsics.yml Read Successfully."  << endl;
%    cout << "----------------------------------------------------------------------" << endl << endl;
%}
%
%/*** Stereo Parameters Configuration function
%  ** Description: Executes the setup of parameters of the StereoBM object by changing the trackbars
%  ** @param rect roi1: Region of Interest 1
%  ** @param rect roi2: Region of Interest 2
%  ** @param StereoBM bm: Correspondence Object
%  ** @param int numRows: Number of Rows of the input Images
%  ** @param bool showStereoBMparams
%  ** Returns:     Nothing
%  ***/
%void StereoProcessor::setStereoParams(){
%    int trackbarsAux[10];
%
%    trackbarsAux[0] = this->stereocfg.preFilterSize*2.5+5;
%    trackbarsAux[1] = this->stereocfg.preFilterCap*0.625+1;
%    trackbarsAux[2] = this->stereocfg.SADWindowSize*2.5+5;
%    trackbarsAux[3] = this->stereocfg.minDisparity*2.0-100;
%    trackbarsAux[4] = this->stereocfg.numberOfDisparities*16;
%    trackbarsAux[5] = this->stereocfg.textureThreshold*320;
%    trackbarsAux[6] = this->stereocfg.uniquenessRatio*2.555;
%    trackbarsAux[7] = this->stereocfg.speckleWindowSize*1.0;
%    trackbarsAux[8] = this->stereocfg.speckleRange*1.0;
%    trackbarsAux[9] = this->stereocfg.disp12MaxDiff*1.0;
%
%    this->bm->setROI1(this->calib.roi1);
%    this->bm->setROI1(this->calib.roi2);
%
%    this->numRows = imageL[0].rows;
%
%    if(trackbarsAux[0]%2==1 && trackbarsAux[0]>=5 && trackbarsAux[0]<=255){
%        //bm.state->preFilterSize = trackbarsAux[0];
%        bm->setPreFilterSize(trackbarsAux[0]);
%    }
%
%    if(trackbarsAux[1]>=1 && trackbarsAux[1]<=63){
%        //bm.state->preFilterCap = trackbarsAux[1];
%        bm->setPreFilterCap(trackbarsAux[1]);
%    }
%
%    if(trackbarsAux[2]%2==1 && trackbarsAux[2]>=5  && trackbarsAux[2]<=255 && trackbarsAux[2]<=numRows){
%        //bm.state->SADWindowSize = trackbarsAux[2];
%        bm->setBlockSize(trackbarsAux[2]);
%    }
%
%    if(trackbarsAux[3]>=-100 && trackbarsAux[3]<=100){
%        //bm.state->minDisparity = trackbarsAux[3];
%        bm->setMinDisparity(trackbarsAux[3]);
%    }
%
%    if(trackbarsAux[4]%16==0 && trackbarsAux[4]>=16 && trackbarsAux[4]<=256){
%        //bm.state->numberOfDisparities = trackbarsAux[4];
%        bm->setNumDisparities(trackbarsAux[4]);
%    }
%
%    if(trackbarsAux[5]>=0 && trackbarsAux[5]<=32000){
%        //bm.state->textureThreshold = trackbarsAux[5];
%        bm->setTextureThreshold(trackbarsAux[5]);
%    }
%
%    if(trackbarsAux[6]>=0 && trackbarsAux[6]<=255){
%        //bm.state->uniquenessRatio = trackbarsAux[6];
%        bm->setUniquenessRatio(trackbarsAux[6]);
%    }
%
%    if(trackbarsAux[7]>=0 && trackbarsAux[7]<=100){
%        //bm.state->speckleWindowSize = trackbarsAux[7];
%        bm->setSpeckleWindowSize(trackbarsAux[7]);
%    }
%
%    if(trackbarsAux[8]>=0 && trackbarsAux[8]<=100){
%        //bm.state->speckleRange = trackbarsAux[8];
%        bm->setSpeckleRange(trackbarsAux[8]);
%    }
%
%    if(trackbarsAux[9]>=0 && trackbarsAux[9]<=100){
%        //bm.state->disp12MaxDiff = trackbarsAux[9];
%        bm->setDisp12MaxDiff(trackbarsAux[9]);
%    }
%
%    if(showStereoParamsValues){
%        cout << getTrackbarPos("preFilterSize",trackbarWindowName)			<< "\t" << trackbarsAux[0] << endl;
%        cout << getTrackbarPos("preFilterCap",trackbarWindowName)			<< "\t" << trackbarsAux[1] << endl;
%        cout << getTrackbarPos("SADWindowSize",trackbarWindowName)			<< "\t" << trackbarsAux[2] << endl;
%        cout << getTrackbarPos("minDisparity",trackbarWindowName)			<< "\t" << trackbarsAux[3] << endl;
%        cout << getTrackbarPos("numberOfDisparities",trackbarWindowName)	<< "\t" << trackbarsAux[4] << endl;
%        cout << getTrackbarPos("textureThreshold",trackbarWindowName)		<< "\t" << trackbarsAux[5] << endl;
%        cout << getTrackbarPos("uniquenessRatio",trackbarWindowName)		<< "\t" << trackbarsAux[6] << endl;
%        cout << getTrackbarPos("speckleWindowSize",trackbarWindowName)		<< "\t" << trackbarsAux[7] << endl;
%        cout << getTrackbarPos("speckleRange",trackbarWindowName)			<< "\t" << trackbarsAux[8] << endl;
%        cout << getTrackbarPos("disp12MaxDiff",trackbarWindowName)			<< "\t" << trackbarsAux[9] << endl;
%    }
%}
%
%void StereoProcessor::imageProcessing(Mat src, Mat imgE, Mat imgED,Mat cameraFeedL,bool isTrackingObjects){
%    Mat erosionElement = getStructuringElement( MORPH_RECT,Size( 2*EROSION_SIZE + 1, 2*EROSION_SIZE+1 ),Point( EROSION_SIZE, EROSION_SIZE ) );
%    Mat dilationElement = getStructuringElement( MORPH_RECT,Size( 2*DILATION_SIZE + 1, 2*DILATION_SIZE+1 ),Point( DILATION_SIZE, DILATION_SIZE ) );
%    Mat imgEBGR,imgEDBGR;
%    Mat imgEDMedian,imgEDMedianBGR;
%    int x,y;
%
%    //Mat imgThreshold;
%    static Mat lastimgThreshold;
%    int nPixels,nTotal;		  	//static int lastThresholdSum=0;
%
%    // Near Object Detection
%
%    //Prefiltering
%    // Apply Erosion and Dilation to take out spurious noise
%    erode(src,imgE,erosionElement);
%    dilate(imgE,imgED,erosionElement);
%
%    applyColorMap(imgE,imgEBGR, COLORMAP_JET);
%    applyColorMap(imgED,imgEDBGR, COLORMAP_JET);
%
%    // Apply Median Filter
%    //GaussianBlur(imgED,imgEDMedian,Size(3,3),0,0);
%    medianBlur(imgED,imgEDMedian,5);
%    applyColorMap(imgEDMedian,imgEDMedianBGR, COLORMAP_JET);
%
%    // Thresholding
%    //adaptiveThreshold(imgEDMedian,imgThreshold,255,ADAPTIVE_THRESH_MEAN_C,THRESH_BINARY,11,-1);
%    //adaptiveThreshold(imgEDMedian,imgThreshold,255,ADAPTIVE_THRESH_GAUSSIAN_C,THRESH_BINARY,11,0);
%    threshold(imgEDMedian, imgThreshold, THRESH_VALUE, 255,THRESH_BINARY);
%    erode(imgThreshold,imgThreshold,erosionElement);
%    dilate(imgThreshold,imgThreshold,dilationElement);
%
%    // Solving Lighting Noise Problem
%    nPixels = sum(imgThreshold)[0]/255;
%    nTotal = imgThreshold.total();
%
%    //	cout << "Number of Pixels:" << nPixels << endl;
%    //	cout << "Ratio is: " << ((float)nPixels)/nTotal << endl << endl;
%
%    if((((float)nPixels)/nTotal)>0.5){
%        //		sleep(1);
%        //		cout << "Lighting Noise!!!" << endl;
%        //		cout << "Number of Pixels:" << nPixels << endl;
%        //		cout << "Ratio is: " << ((float)nPixels)/nTotal << endl << endl;
%
%        // Invalidates the last frame
%        imgThreshold = lastimgThreshold;
%    }else{
%        // Saves the last valid frame
%        lastimgThreshold=imgThreshold;
%        //lastThresholdSum = CurrentThresholdSum;
%    }
%
%    // Output
%    //imshow("Eroded Image",imgE);
%    //imshow("Eroded Image BGR",imgEBGR);
%    //imshow("Eroded+Dilated Image",imgED);
%    //imshow("Eroded+Dilated Image BGR",imgEDBGR);
%    //imshow("Eroded+Dilated+Median Image",imgEDMedian);
%    //imshow("Eroded+Dilated+Median Image BGR",imgEDMedianBGR);
%
%    //imshow("Thresholded Image",imgThreshold);
%
%    // Tracking Object
%    if(isTrackingObjects){
%        cameraFeedL.copyTo(trackingView);
%        trackFilteredObject(x,y,imgThreshold,trackingView);
%        //imshow("Tracking Object",trackingView);
%    }
%}
%
%//Saving Previous Frame
%void StereoProcessor::saveLastFrames(){
%    imageL[0].copyTo(imageL[1]);
%    imageR[0].copyTo(imageR[1]);
%    imageL_grey[0].copyTo(imageL_grey[1]);
%    imageR_grey[0].copyTo(imageR_grey[1]);
%}
%
%void StereoProcessor::setValues(int preFilterSize, int preFilterCap, int sadWindowSize, int minDisparity, int numOfDisparities, int textureThreshold, int uniquenessRatio, int speckleWindowSize, int speckleWindowRange, int disp12MaxDiff) {
%    stereocfg.preFilterSize = preFilterSize;
%    stereocfg.preFilterCap = preFilterCap;
%    stereocfg.SADWindowSize = sadWindowSize;
%    stereocfg.minDisparity = minDisparity;
%    stereocfg.numberOfDisparities = numOfDisparities;
%    stereocfg.textureThreshold = textureThreshold;
%    stereocfg.uniquenessRatio = uniquenessRatio;
%    stereocfg.speckleRange = speckleWindowRange;
%    stereocfg.speckleWindowSize = speckleWindowSize;
%    stereocfg.disp12MaxDiff = disp12MaxDiff;
%
%    std::cout << "SET VALUES!\n";
%}
%\end{lstlisting}

%------------------------------------- Apêndice 2 ---------------------------------------------------
%\chapter{Apêndice 2}
%\label{Apendice2}
%
%Texto do Apêndice 2.
